# -*- coding: utf-8 -*-
"""Membuat Model NLP dengan TensorFlow - Fake News.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BsZ5g9rrVq1h8lteAjAdkWfMBBewsyrD
"""

# install kaggle package
!pip install -q kaggle

# upload kaggle.json
from google.colab import files
files.upload()

# make directory and change permission
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!ls ~/.kaggle

# test kaggle dataset list
!kaggle datasets list

# download dataset, choose 'copy api command' from kaggle dataset
!kaggle datasets download -d hassanamin/textdb3

# unzip
!mkdir fake-news
!unzip textdb3.zip -d fake-news
!ls fake-news

"""# Load Datasets"""

# import pandas
import pandas as pd

# load dataset
df = pd.read_csv('fake-news/fake_or_real_news.csv', sep=',')
df.head(10)

# data columns
df.columns

# total data
df.shape

# data info
df.info()

# categories
df.title.value_counts()

# delete columns (unused column)
df_new = df.drop(columns=['Unnamed: 0'])
df_new

"""# Cleansing Data


"""

# import and download package
import nltk, os, re, string

from keras.layers import Input, LSTM, Bidirectional, SpatialDropout1D, Dropout, Flatten, Dense, Embedding, BatchNormalization
from keras.models import Model
from keras.callbacks import EarlyStopping
from keras.preprocessing.text import Tokenizer, text_to_word_sequence
from keras_preprocessing.sequence import pad_sequences
from keras.utils import to_categorical

from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
from nltk.corpus import wordnet as wn

nltk.download('wordnet')
nltk.download('stopwords')

# lower-case all characters
df_new.title = df_new.title.apply(lambda x: x.lower())
df_new.text = df_new.text.apply(lambda x: x.lower())
df_new.label = df_new.label.apply(lambda x: x.lower())

# removing functuation
def cleaner(data):
    return(data.translate(str.maketrans('','', string.punctuation)))
    df_new.title = df_new.title.apply(lambda x: cleaner(x))
    df_new.text = df_new.text.apply(lambda x: lem(x))
    df_new.label = df_new.label.apply(lambda x: lem(x))

## lematization
lemmatizer = WordNetLemmatizer()

def lem(data):
    pos_dict = {'N': wn.NOUN, 'V': wn.VERB, 'J': wn.ADJ, 'R': wn.ADV}
    return(' '.join([lemmatizer.lemmatize(w,pos_dict.get(t, wn.NOUN)) for w,t in nltk.pos_tag(data.split())]))
    df_new.title = df_new.title.apply(lambda x: lem(x))
    df_new.text = df_new.text.apply(lambda x: lem(x))
    df_new.label = df_new.label.apply(lambda x: lem(x))

# removing number
def rem_numbers(data):
    return re.sub('[0-9]+','',data)
    df_new['title'].apply(rem_numbers)
    df_new['text'].apply(rem_numbers)
    df_new['label'].apply(rem_numbers)

# removing stopword
st_words = stopwords.words()
def stopword(data):
    return(' '.join([w for w in data.split() if w not in st_words ]))
    df_new.title = df_new.title.apply(lambda x: stopword(x))
    df_new.text = df_new.text.apply(lambda x: lem(x))
    df_new.label = df_new.text.apply(lambda x: lem(x))

# view data after cleansing
df_new.head(10)

"""# Model and Plot"""

# data category one-hot-encoding
label = pd.get_dummies(df_new.label)
df_new_cat = pd.concat([df_new, label], axis=1)
df_new_cat = df_new_cat.drop(columns='label')
df_new_cat.head(10)

# change dataframe value to numpy array
news = df_new_cat['title'].values + '' + df_new_cat['text'].values
label = df_new_cat[['fake', 'real']].values

# view news array
news

# view label array
label

# Split data into training and validation
from sklearn.model_selection import train_test_split
news_train, news_test, label_train, label_test = train_test_split(news, label, test_size=0.2, shuffle=True)

# tokenizer
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
 
tokenizer = Tokenizer(num_words=5000, oov_token='x', filters='!"#$%&()*+,-./:;<=>@[\]^_`{|}~ ')
tokenizer.fit_on_texts(news_train) 
tokenizer.fit_on_texts(news_test)
 
sequence_train = tokenizer.texts_to_sequences(news_train)
sequence_test = tokenizer.texts_to_sequences(news_test)
 
padded_train = pad_sequences(sequence_train) 
padded_test = pad_sequences(sequence_test)

# model
import tensorflow as tf
model = tf.keras.Sequential([
    tf.keras.layers.Embedding(input_dim=5000, output_dim=64),
    tf.keras.layers.LSTM(128),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(2, activation='softmax')
])
model.compile(optimizer='adam', metrics=['accuracy'], loss='categorical_crossentropy',)
model.summary()

# callback
class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy')>0.9 and logs.get('val_accuracy')>0.9):
      self.model.stop_training = True
      print("\nThe accuracy of the training set and the validation set has reached > 90%!")
callbacks = myCallback()

# model fit
history = model.fit(padded_train, 
                    label_train, 
                    epochs=50, 
                    validation_data=(padded_test, label_test), 
                    verbose=2, 
                    callbacks=[callbacks], 
                    validation_steps=30)

# plot of accuracy
import matplotlib.pyplot as plt
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model Accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

# plot of loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()